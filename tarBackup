#!/bin/bash

##################################################################################################################
##														##
##   tarBackup shell script Tested on RHEL 5									##
##   Jorge A. Moreno morenog.jorge@gmail.com									##
##   February 28 Backup Bash Shell Script									##
##														##
##   Use script to backup your server using tar/gzip. It can copy the backup to a SMB share on another server, 	##
##   or just keep the backups locally if you wish. I've made some improvements since last versions, so its a	##
##   little more smart now when something bad happens. It also tries to inform you every time something 	##
##   unexpected happens so you always know what is going on. 							##
##														##
##  How to use the script:											##
##														##
##	To use the script, you need to set a few values first. Then you can set your own settings.  		##
##														##
##	To use just drop the script in /etc/cron.daily/ or set it editing crontab. After that just forget it.	##
##	If your cron is well configured you will be mailed of the script output. Anyway you will still be 	##
##	mailed if something bad happens you will always eb informed ;)						##
##														##
##														##
##	>>> For detailed information about configuration and usage explanation consult the README file	<<<	##
##														##
##################################################################################################################

##################################################
##		Variables Declarations		##
##################################################



###########################
## 	 Helpers	 ##	
###########################

#
# Runs hostname cmd to get the short hostname of current server. Hostname is used in the outputName of the final tar file
#
readonly hostname=$(hostname -s)

#
# Runs date cmd in full format. This outputs in Yeah-Month-Day format. This is used as a part of outputName of the final tar file
#
readonly currentDate=$(date +%F)

#
# Runs date cmd to get the current day of the week number. Date's man page states that this version take Monday as day 1. This number is used
# to properly schedule full or incremental backups
#
readonly weekDay=$(date +%u)

#
# Sets the outputName that the file will have. It assumed to always be incremental unless stated otherwise. If so variable will have to be reassigned.
# File name is made of short hostname + incremental_string + current date
#
outputName="$hostname"_Incremental_Backup_"$currentDate"

#
# File name of a full backup. Like outputName but for full backups.
#
readonly fullBackupName="$hostname"_FULL_Backup_"$currentDate"

#
# Holds the number of the day you wanna run a full backup. This number is dependent of date cmd number format check $weekDay for more info
#
readonly fullBackupDay="7"

#
# Helper variable. Used in checks to determinate if backup is full or incremental. Initial value is no really important
# but is safer to set it to something.
#
isFull="true"

#
# Controls whether the backup will be saved in a remote location or it will be saved on local file system. False means backup is local only
#
readonly Remote="false"

#
# If script runs and finds non fatal errors it will mark execution as dirty. Dirty execution logs are sent to root. By default execution is not
# dirty unless marked otherwise. This usually happens when a program return a none zero exit.
#
isDirty="false"

#
# This are the options passed to tar when running the backup. czpf means (c)Create backup (z)Gzip it (p) Preserver permissions (f) is name
# that the tar file will get. Check tar man page for more info
#
readonly tarOptions="czpf"

#
# Tar exclusion folders list. This is ugly, we could have easily used -X option and point to a exclusion list file but I don't like to work with many
# files. If you don't like it you can easily change it ;)
#
tarExcluded=" --exclude=error.log --exclude=/proc/* --exclude=/media/* --exclude=/dev/* --exclude=/mnt/* --exclude=/sys/* --exclude=/tmp/* --exclude=/data/* --exclude=/images/* --exclude=/serverBackups --exclude=/home/moj2ju/Desktop/ --exclude=/usr/share/doc"

#
# If true mail will be deliver to $who2mail whenever script execution is marked as dirty.
#
readonly mailOnDirty="true"

#
# Off by default. Can be used to test for problems, it will output to errorLog ONLY. It outputs some variables data used and
# other performed steps.
#
readonly debugging="false"

###################################################################
##		Remote backups exclusive variables		 ##
###################################################################

#
# Variables $transferAll and $removeOldBackups tested and working

#
# Controls whether the script will transfer all the current backups if remote folder had to be created
#
readonly transferAll="false"

#
# During a remote backup we move last week backups to $lastWeekBackupFolder this controls whether to keep them or delete them every week.
# If true folder will only hold last week backups. Old backups will be deleted!
#
readonly removeOldBackups="true"

#
# During a remote backup if its detected that remote backups are partial or non existent and this differs from local state
# then we set this flag to true so we can act with the transferAll mechanism (assuming is set to true)
#
remoteBackupIncomplete="false"



###########################
##	   Paths	 ##	
###########################

#
# Set the directory you want to make a backup of. Point it to root if you wanna backup all the server data. 
# If you need to exclude certain folders, set this to those folder parent and then set the exclude list in the 
# proper variable.
#
readonly backupTargetDir="/"

#
# Sets the default backups directory, all backups are saved here. If $Remote set to true, this is what will be copied to SMB share
#
readonly defaultBackupDir="/serverBackups"

#
# Helper variable. Holds the current path we are working into. Unlike defaultBackupDir this changes over script execution
#
workDir=$defaultBackupDir

#
# Used by the Mount and Umount programs to (u)mount the SMB share make sure is valid!
#
smbMountPoint="/mnt/samba"						

#
# Server address. You can set and ip and route to the SMB share or name and route
# Example //server.mycompany.com/SMBshare/folder
#
serverPath="//server/share"

#
# This is the path to folder where to store last week backups
# Example: "$smbMountPoint"/oldBackupsFolder
#
lastWeekBackupFolder="$smbMountPoint"/lastWeekBackup

#
# Where we will dump the backups if $Remote set to true
# Example "$smbMountPoint"/BackupsFolder
#
dumpPlace="$smbMountPoint"/Backups

#
# Name and location of the error log file
# Example: "$workDir"/logfile.log
#
errorLog="$workDir"/error.log

#
# Name and location of the incremental snar log file. This file is used by tar to make the incremental backups
# Example: "$workDir"/log.snar
#
snarLog="$workDir"/log.snar

###########################
##	   Samba	 ##	
###########################

#
# Credentials to authenticate on the SMB share. If (when) this change SMB mount will fail if authentication is needed
#
# Usage format: user%pass	Quote it if you need odd characters in your password
# Example: credentials="mike%thisIStheSUPERpassl33t0!%&"
#
# This approach is not very secure!! Improve in later versions, for the time being chmod og-rwx (strip non root from r/w/x)
#
credentials="user%pass"

###########################
##	Programs Names	 ##	
###########################

#
# Following variables are used for error code checking, you can use this to signal who you wanna check via the checkErroCode function
#

#
# Tar program description
#
tar='Tar program with gzip'

#
# Mail program description
#
mail='Mail program'

#
# Mount program description
#
mount='Mount program to mount samba shares'

#
# Umount program description
#
umount='Umount program to Un mount samba shares'


###################################
##	   Programs Paths	 ##	
###################################

# Paths to binaries needed to avoid command not found problems

_mv = $(/bin/mv)

_cp = $(/bin/cp)

_mktemp = $(/bin/mktemp)

_mail = $(/etc/mail)

_tar = $(/bin/tar)

_mount = $(/bin/mount)

_mountCifs = $(/sbin/mount.cifs)

_umount = $(/bin/umount)


###########################
##	   Mail		 ##	
###########################

#
# Who do we mail when something breaks. Default set to root
# This approach assumes you already have your mail server configured. If not mail will only be delivered locally only
#
who2mail="root@localhost"

#
# Mail subject when something breaks
#
mailSubject="There was a problem with the backups"


#
# Holds the email message file name. This is used to store the mail message when something breaks and someone must be informed
#
mailmsg=getMailMsgFile
	
	#
	# Create a tmp file via the mktemp program, this should help to create unique filenames, if it fails by any reason,
	# it complains and function falls back to the old schema (used in previous versions).
	#
	# Returns Mail Message File Name
	#
	function getMailMsgFile
	{
		# Create mail msg file
		fileName=$($_mktemp /tmp/mailMsg.XXXX) || { sayLoud "Could not create mail msg file! will fall back to old method";fileName="mailmsg.txt"; }
		return $fileName
	}
	#
	# Mounts the SMB network share, currently it connects to $serverPath share and it mounts it in $smbMountPoint 
	# Current credentials are static and set in Samba variables section.
	# If (when) this credentials change script will fail to execute.
	#
	# If there's a problem mounting the share then it tries to umount it (just to be on the safe side, via leaveAndMail), 
	# See leaveAndMail function for details
	#
	function mountShare()
	{
		# Sometime permission problems blocks the script from overwriting log. Erase old log before proceeding
		/bin/rm $dumpPlace/error.log  2>/dev/null
		toLog "Rm called for OLD error log"
		
		sayLoud "=============================== "
		sayLoud "Mounting share to copy backup..."
		{
		$_mountCifs $serverPath $smbMountPoint/ -o user=$credentials 2>>$errorLog
		} && { sayLoud "Mount...succesful"; }|| { sayLoud "Mount...Failed!";leaveAndMail; }

	}

	#
	# Checks for folders existence and appropriate permissions on them before attempting to save the backup files
	#
	function checkShare
	{
		checkPathExistence $smbMountPoint
		
		# Since checkPathExistence returns 1 if folder doesnt exists we can test for not zero return codes
		# and do some aditional logic, set remoteBackupIncomplete flag to true and log it
		{
		 checkPathExistence $dumpPlace 
		}|| { remoteBackupIncomplete="true";toLog "Remote backup incomplete"; }

		checkPathExistence $lastWeekBackupFolder

		checkWritePermissions $dumpPlace
		
		checkWritePermissions $lastWeekBackupFolder

		toLog "All checks passed!"
		# If passed all above then continue
	}

	#
	# Check that local paths to be acces exist before using them
	#
	function checkLocalPaths
	{

		# Checks if the folder we want to backup exists, if not we should quit, nothing to backup
		checkBackupTarget
		
		# Checks if folder where we locally put backups exists
		checkPathExistence $defaultBackupDir

	}
	
	#
	# Checks if the folder we want to backup exists, if not we should quit, nothing to backup
	# $1(Arg 1) (optional) Error message to display via sayLoud
	#
	function checkBackupTarget
	{
		path=backupTargetDir
		errorMsg=$1

		if [ ! -d $path ]
		then
			# Default msg
			sayLoud "$path doen't exists, theres nothing to backup! I'll quit"
			
			# Display optional msg if var is set
			if [ ! -z "$errorMsg" ]
			then
				sayLoud $errorMsg
			fi

			leaveAndMail
		fi
	}
	
	
	#
	# Use this to check paths existence
	# $1 (Arg 1) the path to check
	# $2 (Arg 2) (optional) Error message to display via sayLoud
	#
	function checkPathExistence
	{
		path=$1
		errorMsg=$2
		 #Checks if SMB mount point exists, if not there is no point in checking folders below
		if [ ! -d $path ]
		then
			# Default msg
			sayLoud "$path doesn't exists!, I will try to create it"
			
			# Display optional msg if var is set
			if [ ! -z "$errorMsg" ]
			then
				sayLoud $errorMsg
			fi

			{
			mkdir $path 2>>$errorLog
			} && { 
				sayLoud "$path Creation...succesful";
				}|| {
					sayLoud "$path Creation...Failed!";leaveAndMail; 
				}		
	
			# Folder did NOT existed, pass 1 to signal this condition
			return 1;
		fi

	
	}


	#
	# Use this to check for write permissions on a path
	# $1 (Arg 1) the path to check
	# $2 (Arg 2) (optional) Error message to display via sayLoud
	#
	function checkWritePermissions
	{
		path=$1
		errorMsg=$2
		 #Checks if SMB mount point exists, if not there is no point in checking folders below
		if [ ! -d $path ]
		then
			# Default msg
			sayLoud "I have not write permissions on $path I'll quit"
			
			# Display optional msg if var is set
			if [ ! -z "$errorMsg" ]
			then
				sayLoud $errorMsg
			fi
			leaveAndMail
	
		fi

	}
	
	#
	# Informs the user that backup copy is in progress and then it proceeds to copy backup files to the recipient server.
	# After copy to remote server is done, the samba share is unmounted 
	#
	function saveBackup()
	{
		#size=$(du $defaultBackupDir/$outputName.tgz | awk '{ print $1 }')

		# Checks if incomplete for alerts and possible transferAll mechanism
	        if [ "$remoteBackupIncomplete" == "true" ]
        	then
			toLog "Remote Backups were imcomplete, run checkIncompleteBackups"
		
			checkIncompleteBackups
		fi

		if [ "$transferAll" == "false" ]
		then
			# Remote backups seem to be Complete!
			
			toLog "Remote backups look ok"

			# Copy files and tell user copy is in progress
			sayLoud "Saving file please wait..."
			sayLoud "Backup transfer started at `/bin/date`"
			{ 
				$_cp $defaultBackupDir/$outputName.tgz $dumpPlace/ 
			} && { sayLoud "Transfer completed at `/bin/date`";sayLoud "Backup save...succesful";}|| { 
			sayLoud "Backup save...Failed! File transfer was interrupted. Backup could not be saved to its configured destination";leaveAndMail; }
		
			# Copy Incremental data file
			$_cp $defaultBackupDir/log.snar $dumpPlace/ 2>>$errorLog
			toLog "Copy of incremental file called"
		
			toLog "About to copy errorLog to remote share. This will be the last line on remote errorLog this is expected"
	
			# From this point and on, messages will only appear on local errorLog
			$_cp $errorLog $dumpPlace/
			toLog "Copy of erroLog file called"
		
		fi
	}
	
	#
	# use this function to output to user (or console) while also saving the output to the log file
	#
	function sayLoud()
	{
		echo $1
		echo $1 >>$errorLog
	}

	#
	# Use to save args to error log file. Only saves the info if debugging is ON.
	#
	function toLog()
	{
		if [ "$debugging" == "true" ]
		then
			echo $1 >>$errorLog
		fi
	}

	#
	# Creates a tar archives from the $backupTargetDir directory (ussually / ), it excludes as many directories as needed
	#
	# If more are needed simply add them.
	# The function excludes this backup file folder (itself) to avoid recursion ;)
	#
	# Now the backup is incremental, the incremental info in saved in a file name log.snar extension is as specified in tar docs
	#
	function tarIt()
	{
	sayLoud "Creating tar archive..."
		{
		$_tar $tarOptions $1/$outputName.tgz --same-owner --exclude=$1/$outputName.tgz $tarExcluded --listed-incremental $snarLog $backupTargetDir 2>>$errorLog
	
		} && { sayLoud "Tar process...succesful";toLog "This means local file has been succesfully created"; }|| { checkErrorCode "$tar"; }
	}	

        #
        # Checks other programs error codes, you need to pass who (program) had the error for the fucntion
        # to process the logic. Each program has its own error codes so before adding them here check man pages
        # or other documentation. You can find a list of who on the top of the script
        #
        # Example: checkErrorCode "$who"  It is important to use the quotes
        #
        # To check for Tar error codes you should call it like this: checkErrorCode "$tar" Then you can implement your tar
        # exclusive logic in the function for the appropiate error code.
        #
	function checkErrorCode
	{
		errorCode=$? # we have to preserve error code cause it will be overwrite on any next command execution
		who=$1
		# Since we did have errors even if non fatal mark execution as dirty to send mail to root
		isDirty="true"
		toLog "Execution just marked as dirty"
		toLog "By $who with Error code $errorCode"
		# Tar section

		if [ "$who" == "$tar" ]
		then

			# Tar error code number 2 means that Tar finished with errors but but finished anyway
			# so its ussually ok to keep script running even when this happens
			if [ "$errorCode" == 2 ]
			then
				if [ -e $workDir/$outputName.tgz ]
				then
					sayLoud "Tar process...had some errors but managed to finish archive...lets continue"
				else
					sayLoud "Tar process...Failed! Archive file could not be created check error log"
					leaveAndMail
				fi
				#return 0;
				#exit
			else
				sayLoud "Tar process...Failed!"
				leaveAndMail
			fi
		fi
		
		#################################
		#	uMount Section		#
		#################################
		
		# change who for program variable name
		if [ "$who" == "$umount" ]
		then
			# Check if share is not mounted
			if [ "$errorCode" == 1 ]
			then
				# Since we ended up with error code 1 we assume share is no longer mounted
				sayLoud "Umount complained of error 1, share seems to be unmounted already!"

				# if we dont exit here, leaveAndMail will be called again (cause execution was dirty) this
				# will result in a loop calling leaveAndMail infinitly, Exit now to avoid loop condition
				exit
			else
				sayLoud "Unmounting...Failed! This is no relevant to the Backup, however you may want to try and umount SMB share mannualy"
				toLog "about to call leaveAndMail via checkErroCode function"
				leaveAndMail
			fi
		fi

		#################################
		#	Template Section	#
		#################################
		#
		# Use this template for the programs you may wanna check
		#
		# change $name for program variable name, example $tar
		#if [ "$who" == "$name" ]
		#then
		#	# Check error code number
		#	if [ "$errorCode" == number ]
		#	then
		#		# Logic for this code
		#		exit
		#	else
		#		# Logic for other codes
		#	fi
		#fi

	}

	#
	# This functions calls doBackup according how the backup will be, incremental or full. This depends on 2 things
	# Number 1, if today is $fullBackupDay, a full backup will be started. Number 2 if no previos backups were found, run full
	# if none of those were present assume backup is incremental. Bear in mind (however) that the check is only local
	# we don't check for previous remote backups. That is if locally we have a previous full and we'r doing incremental
	# we will only transfer that incremetal to the SMB share. We never check if all files in here are also there, we asume they are.
	#
	function backup()
	{
		if [ "$weekDay" == "$fullBackupDay" ] #Is fullBackupDay do a full backup!
		then
			toLog "Full Backup day"
			isFull=true
			#echo "Full"
			doBackup
			umountNow
		elif [ "$(ls --hide=error.log --hide=lost+found $workDir)" ] # Directory is NOT empty except for error log and lost+found folder, do incremental backup
		then
			toLog "Found other files, backup marked as incremental"
			isFull=false
			#echo "Not empty Incremental"
			doBackup
			umountNow
		else #Is not fullBackupDay but backup folder is empty (No previous full backups). Do a Full backup, cannot do incremental
			toLog "Backups folder is empty, cannot do full"
			#echo "else full"
			isFull=true
			doBackup
			umountNow
		fi
	
		sayLoud "All done"
	}

	#
	# Use this function to umount the SMB share, it checks if backups was set to remote before calling umount
	# if true umount otherwise no point in calling it
	#
	function umountNow
	{	
		toLog "Calling umount"
		if [ "$Remote" == "true" ]
		then
			# If any error stoped the script from umounting the samba share unmounting NOW!
	                {
                	$_umount $smbMountPoint 2>>$errorLog
			} && { sayLoud "Unmounting share...succesful"; }|| { checkErrorCode "$umount"; }
		fi
	}
	
	#
	# This is the actual worker, this function will call all the others in order according with a set of conditions
	#
	# If the backup is marked as FULL then erease old backups in $defaultBackupDir then tar and gzip the $backupTargetDir
	# mount the SMB share and MOVE old backups to $lastWeekBackupFolder (if any old backups) to finish save the backup files 
	# to the SMB share
	# 
	# If backup is marked as NON full ($isFull=false) tar and gzip incremental then mount SMB share and copy the files to it
	#
	# Another check has been added to the script so that it verifies whether the backup is marked as a RemoteBackup or not,
	# if marked as local only then, share wonnt be mounted and no transfer will happen with remote server, only tar ang gzip
	# will be called and backup will remain $defautlbackupDir
	#
	function doBackup
	{
		if [ "$isFull" == "true" ]
		then
			# Today is full backup day
			sayLoud "Preparing to do a FULL backup"
			
			# Rename this backup as full
			outputName="$fullBackupName"

			sayLoud "Deleting current (local) backups..."

			# Clean previous backups, locals first, this will remove everything but current log
			/usr/bin/find $workDir -maxdepth 1 -not -iname "error.log" -not -type d -exec rm {} \; 2>>$errorLog && { 
			sayLoud "Old (local) backups gone!"; } || { sayLoud "Could not erase old (local) backups, will quit!"; leaveAndMail; }
			
			# Create the tar archive
			tarIt $workDir
			
			# After tar all local is done check if we should transfer a remote copy		
			if [ "$Remote" == "true" ]
			then
				# About to clean remote backups mount share now
				mountShare
				checkShare

				# Move previous backups to another folder, move instead of erase to avoid ending up with no backups at all
				# in the event that any error will break the process
				cd $dumpPlace/
				if [ "$(ls -A)" ] # Directory is NOT empty, move backups
				then
					# if set to true we must clean folder first
					if [ "$removeOldBackups" == "true" ]
					then
						toLog "Trying to remove old backups"
						/bin/rm $lastWeekBackupFolder/* && { sayLoud "Old backups removed!"; } || { 
						sayLoud "Could not remove old backups...but I'll continue..."; }
					fi
					# Move last backup to $lastWeekBackupFolder
					$_mv * $lastWeekBackupFolder/ 2>>$errorLog && { sayLoud "Old (remote) backups moved!"; } || { 
					sayLoud "Could not move old (remote) backups, will quit!"; leaveAndMail; }
				else
					sayLoud "I could not found any remote backups. This usually means this is the first run OR backups were ereased";
				fi

				sayLoud "Ready to push new backups"
			
				#Copy backup to server
				saveBackup
			
			elif [ "$Remote" == "false" ]
			then
				alertLocalBackup
			fi
		else
			# Today is incremental backup day
			sayLoud "Preparing to do an Incremental backup"

			#Create the tar archive
			tarIt $workDir
			
			# After tar all local is done, check if we should transfer a remote copy				
			if [ "$Remote" == "true" ]
			then
				#About to clean remote backups mount share now
				mountShare
				checkShare

				#Copy backup to server
				saveBackup	
			
			elif [ "$Remote" == "false" ]
			then
				alertLocalBackup
			fi
		fi
	}
	
	#
	# Alert that backup is only happening on the local filesystem
	#
	function alertLocalBackup()
	{
		sayLoud "Remote backups are disabled, backup will be saved on local file system only!"
		# Successful backups is assumed if we reach this point
		sayLoud "Backup save...succesful";
	}

	#
	# Use this when remoteBackups were incomplete. 
	#  First aler user, and if backup is incremental and $tranferAll is true do a complete transfer of backups. 
	# If backups is full only alert user and continue
	#
	function checkIncompleteBackups
	{
		toLog "No remote folder!"
		toLog "I'll mark execution as dirty to inform of problem above via mail"
		isDirty="true"

		if [ "$isFull" == "true" ]
		then
			sayLoud "Since this is a FULL backup there should be no problems however since we recreated the backup folder you should probably look into why it did not existed in the first place"
		else # Meaning is an incremental backup
			if [ "$transferAll" == "true" ]
			then
				sayLoud " This transfer may take longer than usual, cause we recreated the remote backup folder so Im about to send all current backups stored locally to remote server, please be patient."

				$_cp $defaultBackupDir/*.tgz $dumpPlace/ 2>>$errorLog && { sayLoud "Backup save...sucessful!"; } || { 
				sayLoud "Backup save...failed!";leaveAndMail;}

			else
				sayLoud "Even after a successful folder creation keep in mind that only the most recent backup will be stored, since this is an incremental backup, this means that previous incrementals (if any) or prevoius FULL backups will not be stored on remote server, I will only transfer the most recently created backup, you can always override this behaviour via the transferAll flag"
			fi
		fi
	}

	#
	# Use this function to signal an important error that will make the script fail and exit. This will send an informative mail to $whom2mail person
	# letting them know there was a problem with the backups,.
	#
	# The content of the mail is stored in the variable $mailmsg. The error log is appended along with a human friendly message to the content
	# of the message, to identify the problem.
	#
	function leaveAndMail()
	{
		
		## Append human friendly message, with name of the script and hostname, then append the log 
		echo  > $mailmsg
		echo "There was a problem with the execution of script " $0 " in server " $hostname ". The error log is attached. ">> $mailmsg
		echo  >> $mailmsg
		echo "===================  START ERROR LOG  ===================" >> $mailmsg
		cat $errorLog >> $mailmsg
		echo "===================   END ERROR LOG   ===================" >> $mailmsg
		echo  >> $mailmsg
		
		## Appends done, send the mail
		$_mail -s "$mailSubject" $who2mail < $mailmsg
		
		# Message content no longer relevant delete
		rm $mailmsg && { toLog "$mailmsg deleted!"; } || { toLog "Could not delete $mailmsg"; }
		
		# If any error stopped the script from unmounting the samba share unmounting NOW!
		umountNow
		
		toLog "All must be done, about to quit"
		#Ready to quit
		exit
	
	}
	
	#
	# Use it to check if execution was marked as dirty. If so log it and quit using leaveAndMail
	#
	function checkDirty()
	{
		if [ "$isDirty" == "true" ]
		then
		sayLoud "Execution was Dirty!"
			if [ "$mailOnDirty" == "true" ]
			then
				leaveAndMail
			else
				toLog "MailOnDirty set=$mailOnDirty"
			fi
		fi

	}
	
	function debugDump()
	{
		toLog "Variables data used:"
		echo >> $errorLog
		toLog "Backup mode, Remote=$Remote"
		toLog "Backup target dir=$backupTargetDir"
		toLog "SMB mount point=$smbMountPoint"
		toLog "Server path=$serverPath"
		toLog "Last Week backup folder=$lastWeekBackupFolder"
		toLog "Files dump place=$dumpPlace"
		toLog "Tar options=$tarOptions"
		toLog "Tar exclusion list=$tarExcluded"
		toLog "Credentials are not shown for security reasong. Change this is you want"
	}
	#
	# Call at the start of the program to initialize the first params for the error log file. If function is not called at the script
	# start then log file may not be complete.
	#
	function startLogger()
	{
		# Remove (old) log before writing to it
		/bin/rm $errorLog &> /dev/null

		now=$(date +%c)

		echo "$0 Script Error Log " > $errorLog
		echo >> $errorLog
		echo "Logging started...." $now >> $errorLog
		echo >> $errorLog
		
		if [ "$debugging" == "true" ]
		then
			sayLoud "Debugging is ON"
			echo >> $errorLog 
			debugDump
			echo >> $errorLog 
		else
			toLog "Debugging is OFF" # Not really useful to see this only log it
			echo >> $errorLog
		fi
	}

	# Run everything!	
	workDir=$defaultBackupDir
	startLogger
	backup
	checkDirty
	exit
